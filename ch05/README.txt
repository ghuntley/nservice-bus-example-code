Chapter 5: Advanced Messaging - Example Code

DependencyInjection
-------------------

This solution demonstrates different methods of dependency injection.

The MyMessages assembly just contains one command so that we have a message to
send, and isn't really that interesting. The MyService project is the focus
of this sample.

The ConfigureDependencyInjection class does the work of configuring our services
in the container by using the IWantCustomInitialization interface extension
point. We configure the DateTimeProvider example from the text as a singleton.
We also configure a sample singleton using the alternative RegisterSingleton
method. Lastly we configure a complex service that contains both properties
we configure ourselves as well as additional services that are automatically
injected by the framework.

The Services.cs file contains all of the interfaces for the services we are
injecting, as well as the implementation classes for each service.

The StartAndStop class implements IWantToRunWhenBusStartsAndStops and provides
us a way to send a test message on command from the console window.

Finally, the MyHandler class is where we process the message and verify that
all of our services were properly injected by the framework.

ConventionsSample
-----------------

This solution demonstrates a good framework to specify Unobtrusive Mode
conventions within all our projects. We are using a single top-level namespace
"Packt" in this sample because that is how most people operating within a
corporate environment will structure their code, and because this allows us
to use the name to identify our own assemblies as part of the Unobtrusive Mode
conventions.

The Packt.ConventionsSample.Messages project contains a plethora of messages, 
including commands, events, internal messages, and even messages that are
marked with Express and TimeToBeReceived. It also contains copies of the
ExpressAttribute and TimeToBeReceivedAttribute so that our messages can
be marked with these attributes without needing to depend on an NServiceBus
assembly.

The Packt.ConventionsSample.Service project contains a Startup class that
writes out the metadata for each identified message, so that we can verify
that our conventions are working properly.

The Packt.Conventions assembly contains the code to define our conventions
in the MessageConventions class. This includes using reflection to inspect
any custom attribute our messages are decorated with named ExpressAttribute
or TimeToBeReceivedAttribute in order to support those features.

The ConfigureConventions class shows how we can create an extension method
that we can use when self-hosting NServiceBus within a web application.

For NServiceBus Host endpoints, we simply include the Packt.Conventions
assembly and the message conventions will wire themselves up. When self-
hosting, we include the same assembly but just call .UsingPacktConventions()
within the fluent configuration.

WcfSample
---------

This solution demonstrates exposing a command handler as a WCF web service.

Note that for this solution, you may need to run Visual Studio with
administrative privileges so that the HttpListener for the web service
can properly bind to port 12345 and start listening for incoming web
service requests.

First, run the CommandServer project, which is an NServiceBus.Host endpoint
that contains a WCF service adapter class in the WebServices folder. After
it fully starts up, you should be able to navigate to the following URL
and view the boilerplate web service UI and link to the generated WSDL:

http://localhost:12345/services/thirdpartysvc

Once the service is running, fire up the ConsoleAppClient project, which is
a very basic console application that connects to the web service using a
web service proxy that was generated by Visual Studio.

From the console application, whatever you type is sent in a command message
to the service endpoint. 

	* Type OK to get a response code of OK back.
	* Type anything else to get a response code of Rejected back.
	* Type quit to exit the console app.

